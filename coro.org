#+title: Coro

(introduction)

* Coroutines in C

Coroutines are quite easy to implement. By keeping a separate stack for each coroutine it's easy to switch between them.

I will use C for simplicity. No name mangling, good support for inline assembly. The implementation will be platform dependent.

* Calling a function from assembly

Calling a coroutine will be similar to calling a function. The only difference is that we need to switch out the stack and set up the coroutine return vector.

On Linux we use the [[https://www.uclibc.org/docs/psABI-x86_64.pdf][System V AMD64 ABI]]. More digestible information can be found at [[https://wiki.osdev.org/Calling_Conventions][OS Dev - Wiki - Calling Conventions]].

** Basic rundown of the calling convention

Parameters are passed in ~rdi~, ~rsi~, ~rdx~, ~rcx~, ~r8~, and ~r9~. Return values are in ~rax~, ~rdx~. The stack needs to be 16-byte aligned. The registers ~rbx~, ~rsp~, ~rbp~, ~r12~, ~r13~, ~r14~, ~r15~ are to be preserved by the callee.

Calling a function with two arguments where the address of the function is stored in ~rax~.
#+begin_src asm
    mov rdi,8
    mov rsi, 13
    call rax
#+end_src
Remember, the result of the function call will be in ~rax~.

** Creating an assembly function that can call a function pointer

In addition to calling a function similar to above we also need to create a working function.

#+begin_src asm
call_pointer:
    ;; Arguments:
    ;;   rdi: function pointer to call
    ;;   rsi: pointer to state, passed to function

    ;; store function pointer
    mov rax, rdi

    ;; Call funtion pointer passsing state
    mov rdi, rsi
    call rax

    ret
#+end_src

** Coroutines

For a coroutine we need to create a new stack and replace the stack pointer with a pointer to this stack instead.

*** Caller API
#+begin_src c
// Create coroutine
Coro* coro_create(void(*func)(void*), void* data);
void coro_destroy(Coro* coro);

// Start or continue coroutine
CoroResult coro_continue(Coro* coro);
#+end_src
*** Callee API
#+begin_src c
// Yield execution to caller
void coro_yield();
#+end_src

When finished the coroutine function can simply return.

** Some assembly pitfalls

Make sure which dialect you're using. ~gcc~ defaults to AT&T syntax while Intel syntax is getting more popular. Use the flag ~-masm=intel~ to use Intel syntax. If you do it wrong you will get strange errors.

Is it good idea to use inline assembly? Might be easier, and safer, to use separate assembly functions. Then we just need to respect the calling conventions of the platform.
